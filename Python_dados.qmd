---
title: "Estudo de Python e dados"
author: "Sergio Pedro Rodrigues Oliveira"
date: last-modified
date-format: DD MMMM YYYY
format:
    html:
        code-fold: true
        number-sections: true
    pdf:
      toc: false
      lof: false
      lot: false
      toc-depth: 5
      number-sections: true
      number-depth: 5
      colorlinks: true
      cite-method: biblatex
    docx:
      toc: true
      number-sections: true
      highlight-style: github
jupyter: python3
bibliography: Quarto/pythonbibliografia.bib
csl: Quarto/abnt.csl
---

\thispagestyle{empty}

\newpage
\pagenumbering{roman}

```{=latex}
\setcounter{tocdepth}{4}
\renewcommand{\contentsname}{SUMÁRIO}
\tableofcontents
```

\newpage

```{=latex}
\setcounter{tocdepth}{4}
\renewcommand{\listfigurename}{LISTA DE FIGURAS}
\listoffigures
```
\newpage

```{=latex}
\setcounter{tocdepth}{4}
\renewcommand{\listtablename}{LISTA DE TABELAS}
\listoftables
```

```{python}
#| echo: false
#| error: false
#| warning: false
from IPython.display import Markdown
from tabulate import tabulate
import math
import statistics
import numpy as np
import pandas as pd
import json
```

\newpage
\pagenumbering{arabic}

# Objetivo

O objetivo deste estudo é explorar e documentar as funcionalidades essenciais das principais bibliotecas científicas do Python, como NumPy, Pandas e outras, através de exemplos práticos e casos de uso selecionados. Pretende-se consolidar o conhecimento sobre a manipulação, análise e visualização de dados, servindo como um guia de referência pessoal para futuros projetos de programação científica.

# Básico sobre o `DataFrame` do Pandas

## Introdução

O `Pandas` é uma biblioteca `Python` de código aberto para análise de dados. Ele dá a `Python` a capacidade de trabalhar com dados do tipo planilha, permitindo **carregar**, **manipular**, **alinhar** e **combinar dados** rapidamente, entre outras funções.

Para proporcionar esses recursos mais sofisticados ao `Python`, o `Pandas` introduz dois novos tipos de dados: `Series` e `DataFrame`.
  
  * `DataFrame`
  
  Representa os dados de planilhas ou retangulares completos.
  
  * `Series`
  
  Corresponde a única coluna do `DataFrame`.
  
  * Também podemos pensar em um `DataFrame` do `Pandas` como um `dicionário` ou uma coleção de objetos `Series`.

Por que você deveria usar uma linguagem de programação como `Python` e uma ferramenta como o `Pandas` para trabalhar com dados? Tudo se reduz à automação e à reprodutibilidade.

Objetivos do capítulo:

  1. Carga de um arquivo de dados simples e delimitado.
  2. Como contar quantas linhas e colunas foram carregadas.
  3. Como delimitar quais tipos de dados foram carregados.
  4. Observação de diferentes porções de dados criando subconjuntos de linhas e colunas.

\newpage

## Carregando seu primeiro conjunto de dados

Dado um conjunto de dados inicialmente o carregamos e começamos a observar sua estrutura e contéudo.

O modo mais simples de observar um conjunto de dados é analisar e criar subconjuntos de linhas e colunas específicas. Podemos ver quais tipos de informação estão armazenadas em cada coluna, e começar a procurar padrões por meio de estatísticas descritivas agregadas.

Como o **Pandas** não faz parte da biblioteca-padrão de Python, devemos dizer antes ao Python que carregue a biblioteca (`import`):

```
import pandas as pd
```

Quando trabalhamos com funções **Pandas**, usar o alias `pd` para `pandas` é uma prática comum.

Com a biblioteca carregada, podemos usar a função `read_csv` para carregar um arquivo de dados **CSV**. Para acessar a função `read_csv` do Pandas, usamos a notação de ponto.

```{python}
# Por padrão, a função read_csv lerá um arquivo separado por vírgula;
# Nosso dados Gapminder estão separados por tabulações;
# Podemos usar o parâmetro sep a representar uma tabulação com \t
import pandas as pd # Importa a biblioteca pandas como 'pd'.

# --- Carregamento e Inspeção Inicial ---
df = pd.read_csv('./Data/Cap_01/gapminder.tsv', sep='\t')
# Carrega o arquivo TSV em um DataFrame, usando tabulação como separador.

# Usamos o método head para que Python nos mostre as 5 primeiras linhas
print(df.head())
```

\newpage

* Função `type()`:

  Podemos verificar se estamos trabalhando com um `DataFrame` do Pandas usando a função embutida `type` (isto é, se ele vem diretamente de Python, e não de algum pacote, como o Pandas).

  A função `type()` é conveniente quando começamos a trabalhar com vários tipos diferentes de objetos Python e precisamos saber em qual objeto estamos trabalhando no momento. 

  ```{python}
  print(type(df))
  ```

* Atributo `shape`:

  No momento, o conjunto de dados que carregamos esta salvo como um objeto `DataFrame` do **Pandas**, e é relativamente pequeno.

  Todo objeto `DataFrame` tem um atributo `shape` que nos dará o número de linhas e de colunas desse objeto.

  O atributo `shape` devolve uma tupla[^tupla] na qual o primeiro valor é o número de linhas e o segundo é a quantidade de colunas.

  Com base nesse resultado anteior, podemos ver que nosso conjunto de dados Gapminder tem 1704 linhas e 6 colunas.

  Como `shape` é um atributo de `DataFrame`, e não uma função ou um método, não há parênteses após o ponto. Se você cometer o erro de colocar parênteses depois do atributo `shape`, um erro será devolvido.

  ```{python}
  # Obtém o número de linhas e colunas
  print(df.shape)
  ```

[^tupla]: Uma tupla é semelhante a uma `list`, pois ambas podem armazenar informações heterogêneas. A principal diferença é que o conteúdo de uma tupla é "imutável", o que significa que ela não pode ser alterada. As tuplas também são criadas com parênteses, ().

\newpage

* Atributo `columns`:

  Em geral, quando observamos um conjunto de dados pela primeira vez, queremos saber quantas linhas e colunas há (acabamos de fazer isso).

  Para ter uma noção de quais informações ele contém, devemos observar as colunas.

  Os nomes das colunas, assim como `shape`, são especificados usando o atributo `columns` do objeto dataframe.

  ```{python}
  # Obtém os nomes das colunas
  print(df.columns)
  ```

* Atributo `dtypes`:

  O objeto `DataFrame` do **Pandas** é semelhante a objetos do tipo `DataFrame` que se encontra em outras linguagens (por exemplo, Julia e R).

  Toda coluna (`Series`) deve ser do mesmo tipo, enquanto cada linha pode conter tipos variados.

  Em nosso exemplo atual, podemos esperar que a coluna `country` só contenha strings e que `year` contenha inteiros. No entanto, é melhor garantir que isso seja verdade usando o atributo `dtypes` ou o método `info()`.

  O atributo `dtypes` de um `DataFrame` **Pandas** retorna uma `Series` que descreve o tipo de dado de cada coluna do `DataFrame`. Ele é útil para inspecionar os tipos de dados inferidos ou atribuídos às suas colunas, o que é crucial para operações corretas e eficientes.

  ```{python}
  # Obtém o dtype de cada coluna
  print(df.dtypes)
  ```

\newpage

* Método `info()`:

  O método `info()` de um `DataFrame` **Pandas** é uma ferramenta essencial para obter um resumo conciso e detalhado do seu `DataFrame`. Ele imprime um resumo conciso do `DataFrame`, incluindo:

  ```{python}
  #| echo: false
  #| error: false
  #| warning: false
  #| label: tbl-infoPandas
  #| tbl-cap: Informações do método info() do Pandas

  from IPython.display import Markdown
  from tabulate import tabulate
  table = [["Tipo de índice","Informações sobre o índice \n(por exemplo, RangeIndex)."],
         ["Número de entradas (linhas)","Quantas linhas seu DataFrame possui."],
         ["Número de colunas","Quantas colunas seu DataFrame tem."],
         ["Contagem de valores não nulos por coluna","Para cada coluna, informa quantos valores \nnão são nulos. \nIsso é crucial para identificar dados faltantes."],
         ["Dtype (tipo de dado) de cada coluna","Semelhante ao atributo dtype, \nmas apresentado de forma mais organizada."],
         ["Uso de memória","A quantidade de memória que o DataFrame \nestá utilizando."]
         ]
  Markdown(tabulate(
  table, 
  headers=["Informação","Discrição"],
  colalign=("left","left")
  ))
  ```

  ```{python}
  # Obtém mais informações sobre nossos dados
  print(df.info())
  ```

\newpage

```{python}
#| echo: false
#| error: false
#| warning: false
#| label: tbl-tiposPandasvsPython
#| tbl-cap: Tipos do Pandas versus tipos de Python

from IPython.display import Markdown
from tabulate import tabulate
table = [["object","string","Cadeia de caracteres, usado para representar texto."],
         ["int64","int","Números inteiros."],
         ["float64","float","Números com decimais."],
         ["datetime64","datetime","`datetime` trata-se de uma biblioteca-padrão de Python \n(ou seja, não é carregado por padrão e deve ser importado). \nRepresenta pontos específicos no tempo."]
         ]
Markdown(tabulate(
  table, 
  headers=["Tipo do Pandas","Tipo de Python","Discrição"],
  colalign=("left","left","left")
))
```

\newpage

## Observando colunas, linhas e células

Agora que somos capazes de carregar um arquivo de dados simples, queremos inspecionar o seu conteúdo. Podemos exibir o conteúdo do dataframe com `print`, mas com os dados de hoje em dia, com frequência, haverá células demais para ser possível compreender todas as informações exibidas. Em vez disso, a melhor maneira de observar nossos dados é inspecioná-los por partes, observando vários subconjuntos dos dados.

Já vimos que podemos usar o método `head()` de um dataframe para observar as cinco primeiras linhas de nossos dados. Isso é conveniente para ver se os dados foram carregados de modo apropriado e para ter uma noção de cada uma das colunas, seus nomes e o conteúdo. Às vezes, porém, talvez queiramos ver somente linhas, colunas e valores específicos de nossos dados.

### Obtendo subconjuntos de colunas

Se quiser analisar várias colunas, especifique-as com base nos nomes, nas posições ou em intervalos.

#### Obtendo subconjuntos de colunas pelo nome {.unnumbered}

Se quiser observar apenas uma coluna específica de nossos dados, podemos acessá-la usando colchetes.

```{python}
# Obtém somente a coluna country e a salva em sua própria variável
country_df = df['country']

# Mostra as 5 primeiras observações
print(country_df.head())
```

\newpage

```{python}
# Mostra as 5 últimas observações
print(country_df.tail())
```

Para específicar várias colunas pelo nome, devemos passar uma `list` Python entre os colchetes. Isso pode parecer um pouco estranho, pois haverá dois conjuntos de colchetes.

```{python}
# Observando country, continent e year
subset = df[['country', 'continent', 'year']]
print(subset.head())
```

```{python}
# Mostra as 5 últimas observações
print(subset.tail())
```

Mais uma vez, é possível optar por exibir todo o dataframe subset usando `print`.

\newpage

#### Obter subconjuntos de colunas pela posição dos índices não funciona mais no Pandas v0.20 {.unnumbered}

Ocasionalmente, talvez você queira obter uma coluna em particular com base em sua posição, e não em seu nome. Por exemplo, pode querer a primeira ("country") e a terceira ("year") colunas, ou somente a última ("gdpPercap").

No `pandas v0.20` não é mais possível passar uma lista de inteiros entre colchetes para obter subconjuntos de colunas. Por exemplo, `df[[1]]`, `df[[0,-1]]` e `df[list(range(5))]` não funcionam mais. Há outras formas de obter subconjuntos de colunas, mas não baseadas na técnica usada para obter subconjuntos de linhas.

\newpage

### Obtendo subconjuntos de linhas

Podemos obter subconjuntos de linhas de várias maneiras, pelos nomes ou pelos índices das linhas. A @tbl-il apresenta uma visão geral rápida dos diversos métodos.

```{python}
#| echo: false
#| error: false
#| warning: false
#| label: tbl-il
#| tbl-cap: Diferentes métodos para indexação de linhas (ou de colunas).

from IPython.display import Markdown
from tabulate import tabulate
table = [["`loc`","Subconjunto baseado no rótulo do índice \n(**nome** da linha)."],
         ["`iloc`","Subconjunto baseada no índice da linha \n(**número** da linha)."],
         ["`ix` (não funciona mais no \n`Pandas v0.20`)","Subconjunto baseado no rótulo do índice ou \nno índice da linha."]
         ]
Markdown(tabulate(
  table, 
  headers=["Método para obtenção de subconjuntos","Discrição"],
  colalign=("left","left")
))
```

#### Obtendo subconjuntos de linhas pelo rótulo dos índices: `loc` {.unnumbered}

Vamos observar uma parte de nossos dados `Gapminder`.

```{python}
print(df.head())
```

A esquerda do DataFrame exibido, vemos o que parece ser os números das linhas. Essa lista de valores sem coluna é o rótulo dos índices do dataframe.

Pense no rótulo dos índices como um nome de coluna, mas para linhas em vez de colunas. Por padrão, o Pandas preencherá os rótulos dos índices com os números das linhas (observe que a contagem começa em 0).

Um exemplo comum em que os rótulos dos índices das linhas não são iguais ao número das linhas ocorre quando trabalhamos com dados de séries temporais. Nesse caso, o rótulo dos índices será algum tipo de timestamp. Por exemplo, manteremos os valores default, que são os números das linhas.

Podemos usar o atributo `loc` do dataframe para obter subconjuntos de linhas com base no rótulo dos índices.

```{python}
# Obtém a primeira linha
# Python começa a contar de 0
print(df.loc[0])
```

```{python}
# Obtém a centesima linha
# Python começa a contar de 0
print(df.loc[99])
```

\newpage

**Para obtér a última linha**, uma alternativa seria passar -1 para `loc`, porém acarretaria num erro. Ao passar -1 para `loc` causará um erro, pois o código procurará a linha cujo rótulo de índice (nesse caso, número da linha) seja "-1", e esse valor não existe no nosso exemplo.

Em vez disso, podemos usar um pouco de Python para calcular o número de linhas e passar esse valor para `loc`.

```{python}
# Obtém a última linha (corretamente)
# Usar o primeiro valor dado por shape para obter o número de linhas
number_of_rows = df.shape[0]

# Subtrai 1 do valor, pois queremos obter o número do último índice
last_row_index = number_of_rows - 1

# Obtem agora o subconjunto usando o índice da última linha
print(df.loc[last_row_index])
```

Como alternativa, podemos usar o método `tail` para devolver a última linha, em vez de usar o default de 5.

```{python}
# Método tail, devolvendo a última linha
print(df.tail(n=1))
```

Observe que, quando usamos `tail()` e `loc`, os resultados foram exibidos de modo diferentes. Vamos observar o tipo devolvido quando usamos esses métodos.

\newpage

```{python}
subset_loc = df.loc[0]
subset_head = df.head(n=1)

# type usando loc para uma linha
print("type usando loc para uma linha:")
print(type(subset_loc))

# type usando head para uma linha
print("\ntype usando head para uma linha:")
print(type(subset_head))
```

No ínicio desse capítulo, mencionamos que o Pandas introduziu dois novos tipos de dados em Python. Conforme o método que usamos e a quantidade de linhas retornada, o Pandas devolverá um objeto diferente. O modo como o objeto é exibido pela tela pode ser um indicador do tipo, mas sempre é melhor usar a função `type()` por garantia.

\newpage

**Obtenção de subconjuntos com várias linhas**. Assim como para as colunas, podemos selecionar várias linhas.

```{python}
# Selecione a primeira, a centesima e a milésima linha
# Observe os colchetes duplos, semelhante a sintaxe usada para
#obter subconjuntos com várias colunas
print(df.loc[[0,99,999]])
```

\newpage

#### Obtendo subconjuntos de linhas pelo número das linhas: `iloc` {.unnumbered}

#### Obtenção de subconjuntos de linhas com `ix` não funciona mais no Pandas v0.20 {.unnumbered}

### Combinando tudo

\newpage

## Cálculos agrupados e agregados
## Plotagem básica

\newpage

# Estrutura de dados do Pandas

# Introdução à plotagem

\newpage

# Referências