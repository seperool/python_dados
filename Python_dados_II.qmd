---
title: "Estudo de Python e dados II"
subtitle: "Manipulação de dados: Preparação de dados, dados ausentes e Tidy data"
author: "Sergio Pedro Rodrigues Oliveira"
date: last-modified
date-format: DD MMMM YYYY
lang: pt
format:
    html:
        code-fold: true
        number-sections: true
    pdf:
      toc: false
      lof: false
      lot: false
      toc-depth: 5
      number-sections: true
      number-depth: 5
      colorlinks: true
      cite-method: biblatex
    docx:
      toc: true
      number-sections: true
      highlight-style: github
jupyter: python3
bibliography: Quarto/pythonbibliografia.bib
csl: Quarto/abnt.csl
---

\thispagestyle{empty}

\newpage
\pagenumbering{roman}

```{=latex}
\setcounter{tocdepth}{4}
\renewcommand{\contentsname}{SUMÁRIO}
\tableofcontents
```

\newpage

```{=latex}
\setcounter{tocdepth}{4}
\renewcommand{\listfigurename}{LISTA DE FIGURAS}
\listoffigures
```
\newpage

```{=latex}
\setcounter{tocdepth}{4}
\renewcommand{\listtablename}{LISTA DE TABELAS}
\listoftables
```

```{python}
#| echo: false
#| error: false
#| warning: false

# Bibliotecas para o funcionamento do documento Quarto

from IPython.display import Markdown
from tabulate import tabulate
import math
import statistics
import numpy as np
import pandas as pd
import json
import matplotlib.pyplot as plt
import seaborn as sns
```

\newpage
\pagenumbering{arabic}

# Objetivo

O objetivo deste estudo é explorar e documentar as funcionalidades essenciais das principais bibliotecas científicas do Python, como `NumPy`, `Pandas` e outras, através de exemplos práticos e casos de uso selecionados. Pretende-se consolidar o conhecimento sobre a manipulação, análise e visualização de dados, servindo como um guia de referência pessoal para futuros projetos de programação científica.

\newpage

# Preparação dos dados

## Introdução

A essa altura, você deverá ser capaz de carregar dados no `Pandas` e fazer algumas visualização básica. Essa parte do livro tem como foco várias tarefas de limpeza dos dados. Começaremos com a preparação de um conjunto de dados para análise por meio da combinação de diversos conjuntos.

### Mapa conceitual {.unnumbered}

#. Conhecimento prévio
   #. Carga de dados;
   #. Obtenção de subconjuntos de dados;
   #. Funções e métodos de classe.

### Objetivos {.unnumbered}

Este capítulo abordará:
   
   #. *Tidy data* (dados organizados);
   
   #. Concatenação de dados;
   
   #. Combinação (merge) de conjunto de dados.

```{mermaid}
%%| label: fig-prepdados
%%| fig-cap: "Preparação de dados, principais tópicos."

graph TD
    A[Preparação dos dados] --> B[Tidy Data]
    A --> C[Concatenação de dados]
    A --> D[merge]
```

\newpage

## Tidy data

Hadley Wickham, um dos mais proeminentes membros da comunidade **R**, fala sobre a ideia de *tidy data* (dados organizados). 

Com efeito, ele escreveu um artigo sobre esse conceito no *Journal of Statistical Software*. *Tidy data* é um framework para estruturar [conjuntos de dados]{.underline} a fim de que sejam facilmente [analisados]{.underline}. É usado principalmente como um objetivo a que devemos visar quando [limpamos os dados]{.underline}. Depois que você compreender o que é o conceito de *tidy data*, esse conhecimento fará com que a [coleta de dados]{.underline} seja muito mais fácil.

Então o que é *tidy data*? O artigo de Hadley Wickham o define como um conceito que atende aos seguintes critérios:

#. "**Cada observação deve formar uma linha**" (Observation)

   Uma observação é o conjunto de todas as medidas feitas em uma única unidade (ex: uma pessoa em um exame, um país em um ano específico).

   * O erro comum: Repetir a mesma observação em várias colunas ou espalhar os dados de uma mesma pessoa em tabelas diferentes sem necessidade.

   * O modo Tidy: Se você está analisando a saúde de pacientes, cada linha deve representar um paciente em um momento específico.

#. "**Cada variável deve formar uma coluna**" (Variable)

   Uma variável é um atributo que você mede (ex: Peso, Data, Temperatura).

   * O erro comum: Ter colunas chamadas "Janeiro", "Fevereiro" e "Março". Aqui, o nome da variável é "Mês", e Janeiro/Fevereiro são apenas valores.

   * O modo Tidy: Criar uma coluna única chamada Mes onde os valores são listados.

#. "**Cada tipo de unidade observacional forma uma tabela**"

   Esta regra foca na [organização macro]{.underline}.

   Sobre o terceiro critério do tidy data, [as observações devem ser coerentes com a tabela]{.underline}, tornando-a objetiva quanto ao tipo de informação que deve armazenar. A ideia é que [a tabela tenha um propósito único]{.underline}; ao misturar assuntos diferentes em uma mesma estrutura, fere-se a normalização dos dados.

   * O erro comum: Misturar dados de "Clientes" com dados de "Vendas" na mesma tabela, causando redundância (ex: repetir o endereço do cliente toda vez que ele compra algo).

   * O modo Tidy: Ter uma tabela para Clientes e outra para Vendas, relacionando-as por um ID. Isso facilita a manutenção e evita erros de digitação.

\newpage

### Combinando conjuntos de dados

Começaremos com o último critério de Hadley Wickham para *tidy data*: "cada tipo de unidade de observação forma uma tabela".

Quando os dados estão organizados, é necessário combinar várias tabelas para responder a uma pergunta. Por exemplo, pode haver uma tabela separada que armazene informações de empresas e outra tabela contendo preços de ações. Se quisermos observar os preços de todas as ações no mercado de tecnologia, talvez antes tenhamos de encontrar todas as empresas de tecnologia na tabela de informações sobre empresas e então combinar esses dados com os preços das ações a fim de obter as informações de que precisamos para responder à nossa pergunta.

Os dados podem ter sido separados em tabelas distintas para reduzir a quantidade de informações redundantes (não precisamos armazenar informações sobre as empresas em cada entrada de preço das ações), mas essa organização implica que, como analistas de dados, teremos de combinar os dados relevantes por conta própria para responder à nossa pergunta.

Em outras ocasiões, um único conjunto de dados pode estar dividido em várias partes. Por exemplo, em dados de séries temporais, cada data pode estar em um arquivo separado. Em outro caso, um arquivo pode ter sido separado em partes para que os arquivos individuais fossem menores. Talvez você precise combinar dados de diversas origens para responder a uma pergunta (por exemplo, como combinar latitudes em longitudes com CEPs). Nos dois casos, você terá que combinar dados em um único dataframe de análise.

\newpage

## Concatenação

Uma das maneiras mais (conceitualmente) fáceis de combinar dados é por meio da concatenação.

Podemos pensar na concatenação como uma junção de linhas ou colunas em seus dados. Essa abordagem é possível se seus dados estiverem separados em partes ou se você fez um cálculo que queira concatenar ao seu conjunto de dados existente.

A [concatenação]{.underline} é feita usando a [função `concat` do `Pandas`]{.underline}.

### Adicionando linhas

Vamos começar com alguns conjuntos de dados de exemplo para que você veja o que realmente acontece.

```{python}
import pandas as pd

df1 = pd.read_csv("Cap_04-Preparacao_dados/01-Concatenacao/concat_1.csv")
df2 = pd.read_csv("Cap_04-Preparacao_dados/01-Concatenacao/concat_2.csv")
df3 = pd.read_csv("Cap_04-Preparacao_dados/01-Concatenacao/concat_3.csv")

print("dataframe_csv_1:")
print(df1)
print("dataframe_csv_2:")
print(df2)
print("dataframe_csv_3:")
print(df3)
```

A operação de empilhar dataframes uns sobre os outros é feita com a função `concat` do `Pandas`. Todos os dataframes a serem concatenados são passados em uma `list`.

```{python}
row_concat = pd.concat([df1,df2,df3])
print(row_concat)
```

Como podemos ver, `concat` empilha cegamente os dataframes. Se observar os nomes das linhas (isto é, seus índices), verá que eles são apenas uma versão empilhada dos índices originais das linhas.

Se aplicarmos os diversos métodos para obtenção de subconjuntos, os subconjuntos serão obtidos conforme esperado.

```{python}
#Obtém o subconjunto da quarta linha do dataframe concatenado
print(row_concat.iloc[3,])
```

\newpage

O que acontece se você usar `loc` para obter o subconjunto do novo dataframe?

A função `loc` pega os subconjuntos pelo rótulo (nome da linha), logo pega todos os rótulos com mesmo nome, pegando assim 3 linhas diferentes com mesmo nome.

```{python}
print(row_concat.loc[3])
```

\newpage

#### Concatenar `Series`

Anteriormente apresentamos o processo de criar uma `Series`. No entanto, se criássemos uma nova série para concatenar em um dataframe, ela não seria concatenada corretamente.

```{python}
#Criar uma nova linha de dados
new_row_series = pd.Series(['n1','n2','n3','n4'])
print(new_row_series)
```

```{python}
#Tentando adicionar a nova linha em um dataframe
print(pd.concat([df1,new_row_series]))
```

O primeiro detalhe que você perceba são os valores [`NaN`]{.underline}. É simplesmente o modo Python de representar um ["valor ausente"]{.underline}.

Esperávamos concatenar nossos novos valores como uma linha, mas isso não aconteceu. De fato, nosso código não só não concatenou os valores como uma linha, como também criou uma nova coluna totalmente desalinhada em relação ao restante dos dados.

Se pararmos para pensar no que está acontecendo nesse caso, poderemos ver que o resultado, na verdade, faz sentido. Em primeiro lugar, se observarmos os novos índices adicionados, percebemos que são muito semelhantes aos resultados que obtivemos quando concatenamos dataframes antes. Os índices do objeto `new_row_series` são análogos aos números das linhas do dataframe.

Além disso, como nossa série não tem uma coluna correspondente, nosso `new_row_series` foi adicionado em uma nova coluna.

\newpage

[Para corrigir esse problema]{.underline}, podemos [transformar a nossa série em um dataframe]{.underline}. Esse dataframe contém uma linha de dados, e os nomes das colunas são aqueles com as quais os dados serão associados.

```{python}
#Observe os colchetes duplos
new_row_df = pd.DataFrame([['n1','n2','n3','n4']],columns=['A','B','C','D'])
print(new_row_df)
```

```{python}
print(pd.concat([df1,new_row_df]))
```

\newpage

`concat` é uma função genérica capaz de concatenar vários [dados de uma só vez]{.underline}.

Se você tiver de [concatenar um único objeto a um dataframe existente]{.underline}, a função `append` poderá cauidar dessa tarefa.

[O método `.append()` foi descontinuado]{.underline} nas versões mais recentes do Pandas (acima da 2.0). Atualmente, a forma correta e recomendada de juntar DataFrames é usar o pd.concat().

* Usando um `DataFrame`:

```
print(df1.append(df2))
```

* Usando um `DataFrame` com uma só linha:

```
print(df1.append(new_row_df))
```

* Usando um dicionário Python:

```
data_dict = {
   'A': 'n1',
   'B': 'n2',
   'C': 'n3',
   'D': 'n4'
}

print(df1.append(data_dict, ignore_index=True))
```

\newpage

#### Ignorando o índice

No último exemplo, quando adicionamos um `dict` em um dataframe, tivemos que usar [o parâmetro `ignore_index`]{.underline}. Se observarmos com mais atenção, veremos que [o índice da linha também foi incrementado em 1]{.underline}, e não houve repetição de um valor de índice anterior.

Se simplesmente queremos concatenar os dados, podemos usar o parâmetro [`ignore_index` para reiniciar o índice da linha após a concatenação]{.underline}.

```{python}
row_concat_i = pd.concat([df1,df2,df3],
ignore_index=True)
print(row_concat_i)
```

\newpage

### Adicionando colunas

#### Concatenando colunas - axis {.unnumbered}

Concatenar colunas é muito semelhante a concatenar linhas. A principal diferença esta no parâmetro `axis` da função `concat`.

O valor [default de `axis` é `0`]{.underline}, portanto ele concatenará os [dados nas linhas]{.underline}. Entretanto, se passarmos [`axis=1`]{.underline} para a função, [os dados serão concatenados nas colunas]{.underline}.

```{python}
col_concat = pd.concat([df1,df2,df3],
axis=1)
print(col_concat)
```

#### Subconjuntos colunas {.unnumbered}

Se tentarmos obter um [subconjunto de dados com base nos nomes das colunas]{.underline}, teremos um resultado similar aquele obtido se concatenássemos por linha e gerássemos um subconjunto pelo índice da linhas.

```{python}
print(col_concat['A'])
```

\newpage

#### Adicionar uma única coluna {.unnumbered}

[Adicionar uma única coluna]{.underline} em um dataframe pode ser feito diretamente, [sem usar nenhuma função específica do Pandas]{.underline}.

Basta específicar [um novo nome de coluna e o vetor]{.underline} que você quer que seja atribuído a essa nova coluna.

```{python}
col_concat['new_col_list'] = ['n1','n2','n3','n4']
print(col_concat)
```

```{python}
col_concat['new_col_series'] = pd.Series(['n1','n2','n3','n4'])
print(col_concat)
```

Usar a função `concat` continua funcionando, desde que você lhe passe um dataframe. Essa abordagem exige um pouco mais de código desnecessário.

\newpage

#### Reiniciando índices colunas {.unnumbered}

Por fim, podemos [reiniciar os índices das colunas]{.underline} para que [não tenhamos nomes duplicados]{.underline}.

```{python}
print(pd.concat([df1,df2,df3], axis=1, ignore_index=True))
```

\newpage

### Concatenação com índices diferentes

Os exemplos apresentados [até agora partiram de pressuposto]{.underline} de que estávamos executando uma [concatenação simples de linha ou de coluna]{.underline}. Também foi suposto que a(s) nova(s) linha(s) tinha(m) os mesmos nomes de colunas ou que a(s) coluna(s) tinha(m) os mesmos índices de linha.

Esta seção aborda o que acontece quando os índices das linhas e das colunas não estão alinhados.

#### Concatenando linhas com colunas diferentes

Vamos modificar nossos dataframes para os próximos exemplos:

```{python}
df1.columns = ['A','B','C','D']
df2.columns = ['E','F','G','H']
df3.columns = ['A','C','F','H']
```

```{python}
print(df1)
```

```{python}
print(df2)
```

```{python}
print(df3)
```

\newpage

Se tentarmos concatenar esses dataframes como fizemos anteriormente, os dataframes agora serão muito mais do que simplesmente empilhados uns sobre os outros. [As colunas se alinharão e `NaN` preencherá qualquer área que estaja faltando]{.underline}.

```{python}
row_concat = pd.concat([df1,df2,df3])
print(row_concat)
```

Uma maneira de evitar a inclusão de valores `NaN` é manter [somente as colunas que sejam compartilhadas pela lista de objetos a serem concatenados]{.underline}. Um parâmetro chamado `join` faz isso.

Por padrão, seu valor é `outer`, o que significa que todas as colunas serão mantidas.

Porém, [podemos definir `join='inner'` para manter somente as colunas que sejam compartilhadas entre os conjuntos de dados]{underline}.

Se tentarmos manter apenas as colunas de todos os três dataframes, teremos um dataframe vazio, pois não há nenhuma coluna em comum.

```{python}
print(pd.concat([df1,df2,df3], join='inner'))
```

\newpage

[Se usarmos os dataframes que tenham colunas em comum, somente aquelas que sejam compartilhadas por todos serão devolvidas]{.underline}.

```{python}
print(pd.concat([df1,df3],ignore_index=False, join='inner'))
```

\newpage

#### Concatenando colunas com linhas diferentes


\newpage

## Combinando vários conjuntos de dados
## Conclusão

\newpage

# Dados Ausentes
# Tidy data (dados organizados)

\newpage

# Referências